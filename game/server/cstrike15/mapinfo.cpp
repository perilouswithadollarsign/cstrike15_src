//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
//=============================================================================//

#include "cbase.h"
#include "mapinfo.h"
#include "cs_gamerules.h"

LINK_ENTITY_TO_CLASS( info_map_parameters, CMapInfo );

BEGIN_DATADESC( CMapInfo )

	DEFINE_INPUTFUNC( FIELD_INTEGER, "FireWinCondition", InputFireWinCondition ),
	DEFINE_KEYFIELD( m_iPetPopulation, FIELD_INTEGER, "petpopulation"  ),
	DEFINE_KEYFIELD( m_bUseNormalSpawnsForDM, FIELD_BOOLEAN, "usenormalspawnsfordm"  ),
	DEFINE_KEYFIELD( m_bDisableAutoGeneratedDMSpawns, FIELD_BOOLEAN, "disableautogenerateddmspawns"  ),
	DEFINE_KEYFIELD( m_flBotMaxVisionDistance, FIELD_FLOAT, "botmaxvisiondistance"  ),
	DEFINE_KEYFIELD( m_iHostageCount, FIELD_INTEGER, "hostagecount"  ),

END_DATADESC()

CMapInfo *g_pMapInfo = NULL;


CMapInfo::CMapInfo()
{
	m_flBombRadius = 500.0f;
	m_iBuyingStatus = 0;
	m_flBotMaxVisionDistance = -1.0f;

	if ( g_pMapInfo )
	{
		// Should only be one of these.
		Warning( "Warning: Multiple info_map_parameters entities in map!\n" );
	}
	else
	{
		g_pMapInfo = this;
	}
}


CMapInfo::~CMapInfo()
{
	if ( g_pMapInfo == this )
		g_pMapInfo = NULL;
}
 

bool CMapInfo::KeyValue( const char *szKeyName, const char *szValue )
{
	if (FStrEq(szKeyName, "buying"))
	{
		m_iBuyingStatus = atoi(szValue);
		return true;
	}
	else if (FStrEq(szKeyName, "bombradius"))
	{
		m_flBombRadius = (float)(atoi(szValue));
		if (m_flBombRadius > 2048)
			m_flBombRadius = 2048;
		
		return true;
	}
	
	return BaseClass::KeyValue( szKeyName, szValue );
}


void CMapInfo::Spawn( void )
{ 
	SetMoveType( MOVETYPE_NONE );
	SetSolid( SOLID_NONE );
	AddEffects( EF_NODRAW );
}

void CMapInfo::InputFireWinCondition(inputdata_t &inputdata )
{
	CSGameRules()->TerminateRound( 5, inputdata.value.Int() );
}
